<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>FiltrOmatic</title>
	</head>
		<div id="imagen_original" >
			<p>Imagen Original</p>
			<canvas id="canvas" width="500" height="300" style="border:#000 solid 1px;" />
		</div>
		<div class="filtros_disponibles" >
			<p> Listado de filtros disponibles</p>
		<ul>
		  <li class="filtro">Filtro X</li>
		</ul>
		</div>
		<div id="imagen_filtrada" >
			 <p> Aca se ve la imagen con el filtro deseado </p>
			<canvas id="canvas2" width="500" height="300" style="border:#000 solid 1px;" />
		</div>
		<div id="guardarImagen">
			<p> Si desea Guardar esta imagen en su ordenador de click en el boton </p>
			<input id="inputFileNameToSaveAs">
			<button onclick="salvarImagen()"> Salvar Foto </button>
		</div>
	<script >


	  var ctx = document.getElementById("canvas").getContext("2d");
	  var width = 500;
	  var height =300;
		var ctx2 = document.getElementById("canvas2").getContext("2d");


	var image1 = new Image();
	image1.src = "imagen1.jpg"; // asigna la direccion de donde cargar la imagen

	image1.onload = function(){  // realiza la funcion despues de que cargo la imagen y con esto evita error
	  myDrawImageMethod(this);
	}

		function myDrawImageMethod(image){
	  ctx.drawImage(image,0,0 ,canvas.width,canvas.height);
	  imageData =  ctx.getImageData(0,0, canvas.width,canvas.width);

		// Aca podria poner un case que me de la opcion de que filtro ponerle

			function realizar_Negativo(){
			 for (x=0; x<width; x++){
			    for (y=0; y<height; y++){
			      // Negativo
			      setPixel(imageData, x, y, 255-getRed(imageData,x,y),255-getGreen(imageData,x,y),255-getBlue(imageData,x,y), 255);
					}
			 }
		}

		// Gray Scale
			function realizar_Gray_Scale(){
				for (x=0; x<width; x++){
					 for (y=0; y<height; y++){
				      prom = (getRed(imageData2,x,y) + getGreen(imageData2,x,y) + getBlue(imageData2,x,y))/3;
				      setPixel(imageData2, x, y, prom ,prom ,prom , 255);
						}
				}
			 }
      // Sepia
			function realizar_Sepia(){
				for (x=0; x<width; x++){
		 	    for (y=0; y<height; y++){
				      red = getRed(imageData3,x,y);
				      green = getGreen(imageData3,x,y);
				      blue = getBlue(imageData3,x,y);

				      sepiaR = Math.floor(0.393*red + 0.769*green+ 0.189*blue);
				      sepiaG = Math.floor(0.349*red + 0.686*green + 0.168*blue);
				      sepiaB = Math.floor(0.272*red + 0.534*green + 0.131*blue);
				      setPixel(imageData3, x, y, sepiaR,sepiaG,sepiaB, 255);
					}
			 	}
			 }

	      // Binarizacion

			function realizar_Binarizacion(){
				for (x=0; x<width; x++){
		 	    for (y=0; y<height; y++){
			      prom2 = (getRed(imageData4,x,y) + getGreen(imageData4,x,y) + getBlue(imageData4,x,y))/3;
			      if (prom2 < 128){// el 128 deberia se una variable editable por el usuario el cual maneje el rango de cambio
			        prom2 = 0;
			      }
			      else {
			        prom2 = 255;
			      }
			      setPixel(imageData4, x, y, prom2 ,prom2 ,prom2 , 255);
			   }
	  		}
			}

	/*
	    // Brillo
	    red = getRed(imageData3,x,y);
	    green = getGreen(imageData3,x,y);
	    blue = getBlue(imageData3,x,y);

	    var  brillo = 40;
	      red+= brillo;
	      green+= brillo;
	      blue+= brillo;
	      if  ((red > 255) or (red < 0)){
	        if (red >255){
	          red=255;
	        }
	        else {
	          red=0;
	        }
	      }
	      if  ((green > 255) or (green < 0)){
	        if (green >255){
	          green=255;
	        }
	        else {
	          green=0;
	        }
	      }

	      if  ((blue > 255) or (blue < 0)){
	        if (blue >255){
	          blue=255;
	        }
	        else {
	          blue=0;
	        }
	      }
	*/

	  ctx2.putImageData(imageData,0, 0);
	}


	// Get de los colores
	function getRed(imagedata, x, y){
	  index = (x + y * imageData.width)*4;
	  return imageData.data[index+0];
	}

	function getGreen(imagedata, x, y){
	  index = (x + y * imageData.width)*4;
	  return imageData.data[index+1];
	}

	function getBlue(imagedata, x, y){
	  index = (x + y * imageData.width)*4;
	  return imageData.data[index+2];
	}


	function setPixel(imageData, x, y, r, g, b, a){
		index = (x + y * imageData.width) * 4;
		imageData.data[index+0] = r;
		imageData.data[index+1] = g;
		imageData.data[index+2] = b;
		imageData.data[index+3] = a;
	}

	</script>
	<script type="text/javascript" src="js/function.js"></script>
	<script type="text/javascript" src="js/jquery-3.2.1.min.js"></script>
	</body>

</html>
